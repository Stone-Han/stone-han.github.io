<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本文介绍常用的数据结构和算法，并给出每种数据结构和算法对应的经典习题，详细的解答可以参考下一篇习题解。本文的目录如下：  基础的数据结构 高级数据结构 排序算法 递归和回溯算法 深度优先遍历和广度优先遍历算法 动态规划 二分搜索和贪婪算法">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="http://example.com/2019/12/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="StoneHan&#39;s blog">
<meta property="og:description" content="本文介绍常用的数据结构和算法，并给出每种数据结构和算法对应的经典习题，详细的解答可以参考下一篇习题解。本文的目录如下：  基础的数据结构 高级数据结构 排序算法 递归和回溯算法 深度优先遍历和广度优先遍历算法 动态规划 二分搜索和贪婪算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.itdaan.com/imgs/9/3/5/0/40/58368b6e5995569350d7889020af997a.jpe">
<meta property="article:published_time" content="2019-12-26T10:25:09.000Z">
<meta property="article:modified_time" content="2022-04-23T10:40:21.196Z">
<meta property="article:author" content="StoneHan">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.itdaan.com/imgs/9/3/5/0/40/58368b6e5995569350d7889020af997a.jpe">


<link rel="canonical" href="http://example.com/2019/12/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2019/12/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/","path":"2019/12/26/数据结构和算法/","title":"数据结构与算法"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>数据结构与算法 | StoneHan's blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">StoneHan's blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Stone的个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">基础数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.1.</span> <span class="nav-text">数组、字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">1.3.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.</span> <span class="nav-text">回溯算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">1.5.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88"><span class="nav-number">2.</span> <span class="nav-text">深度优先和广度优先</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS"><span class="nav-number">2.1.</span> <span class="nav-text">DFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BFS"><span class="nav-number">2.2.</span> <span class="nav-text">BFS</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="StoneHan"
      src="/images/3.jpg">
  <p class="site-author-name" itemprop="name">StoneHan</p>
  <div class="site-description" itemprop="description">想把你写成一首歌，想养一只猫</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Stone-Han" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Stone-Han" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:592024747@qq.com" title="E-Mail → mailto:592024747@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/12/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/3.jpg">
      <meta itemprop="name" content="StoneHan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StoneHan's blog">
      <meta itemprop="description" content="想把你写成一首歌，想养一只猫">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="数据结构与算法 | StoneHan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构与算法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-26 18:25:09" itemprop="dateCreated datePublished" datetime="2019-12-26T18:25:09+08:00">2019-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-23 18:40:21" itemprop="dateModified" datetime="2022-04-23T18:40:21+08:00">2022-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>本文介绍常用的数据结构和算法，并给出每种数据结构和算法对应的经典习题，详细的解答可以参考下一篇习题解。本文的目录如下：</p>
<ol>
<li>基础的数据结构</li>
<li>高级数据结构</li>
<li>排序算法</li>
<li>递归和回溯算法</li>
<li>深度优先遍历和广度优先遍历算法</li>
<li>动态规划</li>
<li>二分搜索和贪婪算法</li>
</ol>
<span id="more"></span>

<h1 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h1><h2 id="数组、字符串"><a href="#数组、字符串" class="headerlink" title="数组、字符串"></a>数组、字符串</h2><ul>
<li>数组的优点：简单、根据下表查询O(1)</li>
<li>缺点：分配连续空间、查找、添加、删除某个元素时必须遍历</li>
<li>例子：242有效的字母异位词<br>思路：由于字母都是小写且只有26个，因此可以用一个长度为26的数组对每个单词中字母出现的顺序计数，判断是否一致。或者第一个单词累加，第二个减，看这个数组的每个字母的计数是否为0.</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li><p>优点：灵活分配内存，删除、添加元素O(1)</p>
</li>
<li><p>缺点：不能locate</p>
</li>
<li><p>解题技巧：</p>
</li>
<li><p>快慢指针（有时需要用三个指针）：【翻转、倒数k个元素、寻找中间位置元素、判断链表是否有环】</p>
</li>
<li><p>构建虚假的链表头：两个排序链表整合、将链表奇数偶数分离<br>例题：k个一组翻转链表<br>##栈###</p>
</li>
<li><p>特点：后进先出LIFO</p>
</li>
<li><p>算法基本思想：用一个单链表实现，只关心上一次操作，处理完上一次的操作后能在O(1)的时间内查找到更前一次的操作。（不用数组的原因：数组的长度变化不好控制）<br>例题：20.有效的括号 739.每日温度</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2></li>
<li><p>特点：先进先出</p>
</li>
<li><p>算法思想：双链表</p>
</li>
<li><p>常用场景：广度优先遍历<br>###双端队列####</p>
</li>
<li><p>特点：双链表、头尾两端可以在O(1)的时间进行查看、添加和删除</p>
</li>
<li><p>常用场景：实现长度动态变化的窗口或者连续区间</p>
</li>
<li><p>例题：239.滑动窗口的最大值<br>##<strong>树</strong>###</p>
</li>
<li><p>树的共性：结构直观、通过树的问题考察递归算法</p>
</li>
<li><p>常考的树的形状：普通二叉树、平衡二叉树、完全二叉树、【二叉搜索树】、四叉树、多叉树。（特殊的树：红黑树、自平衡二叉搜索树不必花费太多时间）</p>
</li>
<li><p>操作：遍历：前序（搜索、建立二叉树）、【中序】（二叉搜索树）、后序（需要利用左右子树信息）掌握递归、非递归写法。<br>例题：230.二叉搜索中第k小的元素</p>
</li>
</ul>
<p>#高级数据结构##</p>
<ul>
<li>优先队列：常见考点、面试中可以直接使用</li>
<li>图：广泛运用的数据结构，大数据：社交网络、地图</li>
<li>前缀树：难题、能够熟练实现及运用</li>
<li>线段树和树状数组：应用场合比较明确：在图片中修改像素的颜色、求解任意矩形区间的灰度平均值需要用二位的线段树。</li>
</ul>
<p>##优先队列###</p>
<ul>
<li><p>与普通队列区别：每次取出的元素是队列中优先级最高的，优先级别可以自己定义<br>常用场景：从杂乱无章的数据中按照一定的顺序（优先级）筛选数据。例如：找出前k大的数。</p>
</li>
<li><p>本质：二叉堆结构，利用数组实现完全二叉树</p>
</li>
<li><p>特性：</p>
<ul>
<li>数组里的第一个元素拥有最高优先级，给定一个下标i，那么对于array[i]而言。     父节点下标为<code>(i-1)/2</code>;          </li>
<li>左侧子节点<code>为2*i+1</code>;右侧子节点下标为<code>2*i+2</code>;每个元素的优先级必须高于它两侧子节点。</li>
</ul>
</li>
<li><p>操作：向上筛选；向下筛选；</p>
<ul>
<li>向上筛选：新的数据加入到优先队列后对数据进行重新筛选，高度为树的高度。复杂度为O(logk)</li>
<li>向下筛选：堆顶元素被取出，将最后一个元素放入堆顶，重新筛选。复杂度为O(logk)</li>
<li>优先队列初始化：O(n)</li>
</ul>
</li>
<li><p>例题：347. 前k个高频元素</p>
</li>
</ul>
<p>##图###</p>
<ul>
<li><p>基础知识：</p>
<ul>
<li><strong>图的存储和表达：邻接矩阵、邻接表</strong></li>
</ul>
</li>
<li><p>算法：</p>
<ul>
<li><strong>图的遍历：深度遍历、广度遍历（重要）</strong></li>
<li><strong>二部图的检测：树的检测、环的检测：有向图、无向图</strong></li>
<li><strong>联合-查找算法（union-find）</strong></li>
<li><strong>拓扑排序</strong></li>
<li><strong>最短路径算法</strong></li>
<li>连通性相关算法</li>
<li>图的着色、旅行商问题等</li>
</ul>
</li>
<li><p>例题：785.判断二分图<br>##前缀树（字典树）###</p>
</li>
<li><p>前缀树广泛应用于字典查找中</p>
<ul>
<li>字典查找：方法一：暴力搜索O(MN)；方法二：前缀树O(M)</li>
</ul>
</li>
<li><p>经典应用：在搜索框输入时，会列出以搜索词开头的相关搜索词；汉语拼音输入法；</p>
</li>
<li><p>重要性质</p>
<ul>
<li>每个节点至少包含两个属性：children和isEnd；children是数组或者集合，包含每个分支中包含的所有字符串；isEnd表示该节点是否为某个字符串的结尾。</li>
<li>前缀树的根节点是空（只关心根节点的children）</li>
<li>除了根节点，其他所有节点都有可能是单词的结尾，叶子节点一定都是单词的结尾</li>
</ul>
</li>
<li><p>操作</p>
<ul>
<li>创建：遍历输入的字符串，对每个字符串的字符进行遍历；从根节点开始，将每个字符加入节点的children字符集中；如果字符集已经包含则跳过；如果当前字符是字符串的最后一个，则isEnd标记为真。</li>
<li>搜索：从根节点出发，逐个匹配输入的前缀字符；如果遇到则向下一层继续搜索；如果没有则返回。</li>
</ul>
</li>
<li><p>例题</p>
</li>
<li><p>212.单词搜索</p>
</li>
</ul>
<p>##线段树###</p>
<ul>
<li>线段树出现的原因：对数组数值频繁更新且的任意区间元素求和的时候需要O(N)的时间，而线段树只需要O(logN)</li>
<li>线段树的概念：按照二叉树形式存储数据，每个节点保存的是数组里某一段的总和。</li>
<li>例题：315.计算右侧小于当前元素的个数：将下标设为数值区间，节点设置为在这个区间的数字个数；遍历数组并更新数中节点的数值；查找的时候从根节点向下遍历即可。</li>
<li>题目特征：区间</li>
</ul>
<p>##树状数组###</p>
<ul>
<li>树状数组出现原因：对数组频繁更新数组的数值且求前k个元素的总和；线段树O(logN);树状数组也可以在O(logN)时间实现，但是代码实现更简单些。</li>
<li>基本特征：<ul>
<li>用数组表示多叉树的结构；优先队列是用数组表示完全二叉树，二树状数组是多叉树。</li>
<li>树状数组的第一个元素是空节点</li>
<li>如果节点tree[y]是tree[x]的父节点，那么需要满足y &#x3D; x - (x &amp;(-x))</li>
</ul>
</li>
<li>例题：308.二维区域和检索-可变：求动态变化矩阵任意子矩阵里数的总和。</li>
</ul>
<p>#排序算法#</p>
<p>基本的排序算法【简单直接、要求没有bug】：</p>
<ul>
<li>冒泡排序</li>
<li>插入排序</li>
</ul>
<p>常考的排序算法【解决大部分关于排序问题的关键】：</p>
<ul>
<li>归并排序</li>
<li>快速排序</li>
<li>拓扑排序</li>
</ul>
<p>其他【掌握好思想，开阔思路】：</p>
<ul>
<li>堆排序</li>
<li>桶排序</li>
</ul>
<p>##冒泡排序##</p>
<pre><code>void BubbleSort(int[] nums)
&#123;
    bool hasExchange = true;
    for (int i=0; i&lt;nums.length-1&amp;&amp; hasExchange;i++)
    &#123;
        hasExchange = false;
        for (int j=0;j&lt;nums.length-1-i;j++)
        &#123;
            if (nums[j]&gt;nums[j+1])
            swap(nums,j,j+1);
            hasExchange =  true;
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li>空间复杂度O(1)；时间复杂度O(N^2)</li>
<li>算法稳定</li>
</ul>
<p>##插入排序</p>
<pre><code>void SelectSort(int[] nums)
&#123;
    for(int i = 1,i&lt;nums.lenth;i++)
    &#123;
        current = nums[i];
        for(j = i-1;j&gt;=0&amp;&amp;nums[j]&gt;current;j--)
        &#123;
            nums[j+1] = nums[j];
        &#125;
        nums[j+1] = current;
    &#125;
&#125;
</code></pre>
<p>##归并排序##</p>
<pre><code>void MergeSort(int[] A,int low, int high)
&#123;
    if (low&gt;=high) return;
    int mid = (low+high)/2;
    MergeSort(A,low,mid);
    MergeSort(A,mid+1,high);
    merge(A,low,mid,high);
&#125;


void merge(int []nums,int low, int mid, int high)
&#123;
    int[] copy = nums.clone();
    int k=low, i=low, j=mid+1;
    while(k&lt;=high)
    &#123;
        if(i&gt;mid)&#123;nums[k++]=copy[j++];&#125;
        else if(j&gt;high)&#123;nums[k++]=copy[i++];&#125;
        else if(copy[j]&lt;copy[i])&#123;nums[k++]=copy[j++];&#125;
        else &#123;nums[k++]=copy[i++];&#125;
    &#125;
        
&#125;
</code></pre>
<p>空间复杂O(n)</p>
<p>##快速排序##</p>
<pre><code>void QuickSort(int[] nums,int low, int high)
&#123;
    if (low&gt;=high) return;
    int p = partition(nums,low,high);
    QuickSort(nums,low,p-1);
    QuickSort(nums,p+1,high);
&#125;
void partition(int[] nums,int low, int high)//获得基准值
&#123;
    swap(nums,randRange(low,high),high);//随机取一个数作为基准值，放在high
    int i,j;
    for(int i=low,j=low;j&lt;high;j++)//每个数和基准值比较，如果当前值比基准值小，将其放在指针i所在的位置
    &#123;
        if(nums[j]&lt;=nums[high])
        swap(nums,i++,j);
    &#125;//循环完毕之后，i左边的数都比基准值小
    swap(nums,i,j);//将基准值放在i的位置，i之后的数都比基准值大
    return i;//返回基准值的位置
&#125;
</code></pre>
<p>空间O(logN)<br>例题：215</p>
<p>##拓扑排序##<br>排序前提：有向图、没有环</p>
<pre><code>void TopSort()//图的广度优先搜索
&#123;
    //adj表示图，indegree表示入度
    Queue&lt;Integer&gt; q = new LinkedList();
    for (int v=0; v&lt;V; v++)//将入度为0的顶点加入队列
    &#123;
        if (indegree[v]==0) q.add(v);
    &#125;
    while (!q.isEmpty())
    &#123;
        int v= q.poll();//从队列中取出顶点
        print(v);
        for(int u=0;u&lt;adj[v].length;u++)//将和这个顶点相邻的定点减1
        &#123;
            if(--indegree[u] == 0)//如果相邻的顶点入度为0，则加入队列
            &#123;
                q.add(u);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>时间复杂度O(N):统计顶点入度，每个顶点遍历一次</p>
<p>#递归、回溯算法#</p>
<p>递归的基本性质：调用函数本身，把大规模问题不断缩小再进行推导<br>回溯：利用递归的性质，从问题起点出发不断尝试，返回一步甚至多步再做选择，直到抵达终点</p>
<p>##递归算法（自顶向下）##<br>使看似复杂的问题变得简洁和易于理解<br>算法思想：</p>
<ul>
<li><p>将问题规模变小（把要实现的递归函数看成已经实现好的）</p>
</li>
<li><p>利用小规模问题中得到的结果（解决这个子问题）</p>
</li>
<li><p>结合当前情况得出最终结果（根据子问题的解得到现在问题的答案）<br>经典例子：汉诺塔问题</p>
<p> void hano(char A, char B, char C, int n)<br> {<br> if (n&gt;0){<br> hano(A,C,B,n-1);<br> move(A,C);<br> hano(B,A,C,n-1);<br> }<br> }</p>
</li>
</ul>
<p>递归写法结构：</p>
<pre><code>function fn(n)
&#123;
//第一步，判断输入或者状态是否非法
    if(input/state is invalid)&#123;
    return;
    &#125;
    
//第二步，判断递归过程是否应该结束
    if(match condition)&#123;
    return some_value;
    &#125;
//第三步，缩小问题规模，递归调用
    result1 = fn(n1);
    result2 = fn(n2);
    ...
//第四步，整合结果
return combine(result1,result2);
&#125;
</code></pre>
<p>例题：91.解码方法；247.中心对称数II<br>递归的时间复杂度分析：</p>
<ul>
<li>迭代法：比如汉诺塔问题，T(n)&#x3D; 1+2T(n-1)+1&#x3D; 2T(n-1)+O(n)&#x3D;…&#x3D;2*2^n</li>
<li>公式法<br>对形如T(n) &#x3D; aT(n&#x2F;b) + f(n)的递归方程，算法复杂度如下：<br><img src="https://www.itdaan.com/imgs/9/3/5/0/40/58368b6e5995569350d7889020af997a.jpe" alt="递归的算法复杂度"><ul>
<li>举例1:<br> T(n) &#x3D; 2T(n&#x2F;2) + n,<br>  a&#x3D;2,b&#x3D;2,f(n)&#x3D;n;<br>  $n^{log_ba}&#x3D;n^1&#x3D;n$, 符合第二种情况，时间复杂度为O(nlogn)</li>
<li>举例2：<br>T(n) &#x3D; 2T(n&#x2F;4) + 1<br>$n^{log_42}&#x3D;sqrt(n)$<br>n&gt;1,sqrt(n)&gt;1, 时间复杂度为O(sqrt(n))</li>
<li>举例3：<br>  T(n) &#x3D; 3T(n&#x2F;2) + $n^2$<br>  $n^{log_23}&#x3D;n^{1.48}&lt;n^2$<br>故，时间复杂度为$O(n^2)$</li>
</ul>
</li>
</ul>
<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>回溯算法和暴力算法的区别是，回溯算法一步一步向前试探，对每一步试探的结果进行评估，再决定是否继续。</p>
<p>解决问题的模板：</p>
<ol>
<li>判断当前情况是否非法，如果非法就立即返回</li>
<li>看看当前情况是否已经满足条件？如果是，就将当前结果保存并返回</li>
<li>在当前情况下遍历所有可能出现的情况，并进行递归</li>
<li>递归完毕后，立即进行回溯，回溯的方法就是取消前一步进行的尝试</li>
</ol>
<p>例题：39.组合总和；52.N皇后II</p>
<p>时间复杂度，以N皇后问题为例：</p>
<pre><code>- 假设backtracking函数的执行时间是T(n)
- 首先每次必须遍历所有列，一共有n列，每一列都要对是否冲突进行检查，最多n列，时间复杂度$O(n^2)$
- 然后，递归尝试每种摆放，每次放好一个，规模-1，执行时间为T(n-1)
- 最后，得到表达式$T(n)= n*T(n-1)+O(n^2)$，用迭代法展开即可得到O(T(n))=n!
</code></pre>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>二叉树的定义和遍历</li>
<li>归并排序、快速排序</li>
<li>动态规划</li>
<li>二分搜索</li>
<li>数学基础：等差数列、等比数列</li>
</ul>
<h1 id="深度优先和广度优先"><a href="#深度优先和广度优先" class="headerlink" title="深度优先和广度优先"></a>深度优先和广度优先</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>DFS解决的是连通性的问题，即给定起始点和终点，判断两点之间是否连通。连通的路径有很多条，找出一条即可。</p>
<p>例题：走迷宫(在矩阵中设置起点和终点，以及墙)</p>
<p>实现：深度优先有两种实现方法：递归和非递归。非递归方法直接用栈来实现。</p>
<p>复杂度分析：邻接表O(V+E)；邻接矩阵$O(V^2)$</p>
<p>寻找最短路径：暴力法，找出所有路径，比较长短； 优化：一边寻找目的地，一边记录和起始顶点的距离，当发现从某个方向用的步数更少，则更新到这个点的步数，如果步数更多，则不用继续尝试。</p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>广度优先搜索一般用来解决最短路径问题，从起始点出发，一层一层遍历，每层结点到起始点步数相同，找到目的地即可结束。</p>
<p>双端BFS是同时从起点和终点开始进行的广度优先搜索，可以大大提高搜索的效率。比如，社交网络中判断两个人通过多少人能够认识对方，从认识的人较少的一方开始遍历。</p>
<p>实现：广度优先遍历用队列进行实现。</p>
<p>复杂度分析：邻接表 O(V+E); 邻接矩阵 O(V^2)</p>
<p>例题：迷宫问题中允许打通3堵墙，应该怎么找到最短路径？</p>
<ul>
<li><p>暴力法：首先枚举所有的拆墙方法，假设共有K堵墙，最多允许拆3堵，有3种方式，可以不拆、只拆一堵、两堵和三堵。那么一共有C(0,K)+C(1,K)+C(2,K)+C(3,K),约为K^3,若允许拆w堵墙，则共有k^w种方式。在这么多情况下再分别进行BFS，整体复杂度为O(n^2*k^w)。</p>
</li>
<li><p>优化：允许打通一堵墙的情况下，分身为两个人进行BFS搜索，复杂度为2O(n^2);允许打通两堵墙的情况下，分身为3个人，复杂度为3O(n^2)……如果第一个人又遇到一堵墙，不需要再次分身，而是记录下来让第二个人搜索，将这个点放入队列即可。4个分身在各自的平面立面搜索，利用三维矩阵记录每个层面的点即可。</p>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/12/26/%E5%AE%9A%E6%8A%95/" rel="prev" title="定投">
                  <i class="fa fa-chevron-left"></i> 定投
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">StoneHan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
